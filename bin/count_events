#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Event Counter CLI Tool
======================

Description:
    This script is a command-line wrapper for the 'event_counter' library.
    It processes multiple input paths independently, providing both 
    per-directory event counts and a final grand total.

Mechanism:
    1. Environment Reliance: It assumes 'lib/' is in PYTHONPATH (set via setup.sh).
    2. Grouped Processing: It iterates through each input argument separately.
    3. Lazy Loading: It uses 'uproot' via the library to read metadata fast.

Usage Examples:
    # 1. Separate reporting for each directory
    count_events ./TTTo2L2Nu ./TTToSemiLeptonic

    # Output format:
    #   [INFO] Scanning directory...
    #   [INFO]   [OK] TTTo2L2Nu -- file1.root: 1000 events
    #   ...
    #   --------------------------------------------------
    #    Summary for  : TTTo2L2Nu
    #    Total Events : 50000
    #   --------------------------------------------------

    # 2. Specific Tree in a specific folder
    count_events /data/store/user/2017/ --tree Runs

Dependencies:
    - python3
    - uproot (pip install uproot)
    - Source 'setup.sh' before running this script.
"""

import sys
import argparse
from pathlib import Path

# ------------------------------------------------------------------------------
# Import Logic
# Relies on PYTHONPATH set by 'source setup.sh'
# ------------------------------------------------------------------------------
try:
    import event_counter
except ImportError:
    print("\n[Error] Could not import 'event_counter'.")
    print("Did you run 'source setup.sh'? Please load the environment first.")
    print(" (If you are developing, ensure 'lib/' is in your PYTHONPATH)\n")
    sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Recursively count events in ROOT files with grouped reporting."
    )
    
    # Input arguments
    parser.add_argument(
        "inputs", 
        nargs='+', 
        help="Input files or directories (separate multiple inputs with space)"
    )
    
    # Optional arguments
    parser.add_argument(
        "--tree", "-t", 
        default="Events", 
        help="Name of the TTree to count (default: Events)"
    )

    args = parser.parse_args()
    
    grand_total = 0
    total_files_processed = 0
    
    # Instantiate counter
    counter = event_counter.EventCounter(tree_name=args.tree)

    print(f"\nTarget Tree: '{args.tree}'\n")

    # ---------------------------------------------------------
    # Process each input argument separately
    # ---------------------------------------------------------
    for input_path in args.inputs:
        path_obj = Path(input_path)
        # Use filename as label (e.g., directory name)
        label = path_obj.name 

        # 1. Expand files for THIS input only
        target_files = event_counter.expand_file_paths([input_path])
        
        if not target_files:
            print(f"[Warning] No ROOT files found in: {input_path}")
            continue
            
        # 2. Run Counter for this batch
        # 'label' is used for logging prefix (e.g. "[OK] label -- file.root")
        sub_total = counter.count(target_files, label=label)
        
        # 3. Print Sub-summary
        print("-" * 50)
        print(f" Summary for  : {label}")
        print(f" Files Found  : {len(target_files)}")
        print(f" Total Events : {sub_total}")
        print("-" * 50 + "\n")
        
        # Accumulate
        grand_total += sub_total
        total_files_processed += len(target_files)

    # ---------------------------------------------------------
    # Final Grand Total (Only show if multiple inputs were given)
    # ---------------------------------------------------------
    if len(args.inputs) > 1:
        print("=" * 50)
        print(f" GRAND TOTAL Summary")
        print(f" Inputs Processed : {len(args.inputs)}")
        print(f" Total Files      : {total_files_processed}")
        print(f" Total Events     : {grand_total}")
        print("=" * 50)

if __name__ == "__main__":
    main()
